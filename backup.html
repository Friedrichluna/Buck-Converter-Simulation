<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buck Converter Simulation</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
	<canvas id="canvas" width="800" height="400"></canvas>
    <div>
        <label for="currentInput">Current (A): </label>
        <input type="number" id="currentInput" value="1" step="0.1">
        <label for="voltageInput">Voltage (V): </label>
        <input type="number" id="voltageInput" value="5" step="0.1">
    </div>
    <div id="coordinates">Coordinates: (0, 0)</div>
    <canvas id="plot" width="800" height="600"></canvas>
    <script>
        // Parameter
        const V_in = 20; // Eingangsspannung in Volt
        const L = 99e-3; // Induktivität in Henry
        const C = 1e-3; // Kapazität in Farad
        const R_load = 10; // Lastwiderstand in Ohm
        const f = 100e3; // Schaltfrequenz in Hz
        const T = 1 / f; // Schaltperiode in Sekunden
        const dt = 1e-4; // Zeitschritt
		
        // Initialbedingungen
        let i_L = 0; // Anfangsstrom durch die Induktivität
		let i_C = 0; //Kondensatorstrom
        let v_C = 0; // Anfangsspannung über den Kondensator
        let q = 1; // Initialer Schaltzustand (geschlossen)
        let stopSimulation = false; // Flag to stop the simulation
        let breakSimulation = false; // Flag to break the simulation
		let counter = 0;

        // Canvas setup
        const canvas = document.getElementById('plot');
        const ctx = canvas.getContext('2d');

        let t_total = 0; // Gesamtzeit
        const t_data = [];
        const iL_data = [];
        const vC_data = [];
        const q_data = [];

        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                q = 1 - q; // Schaltzustand wechseln
            } else if (event.key === 's') {
                stopSimulation = true; // Stoppen der Simulation
            } else if (event.key === 'b') {
                breakSimulation = !breakSimulation; // Pausieren und Fortsetzen der Simulation
            }
        });

        function buckConverterDynamics(i_L, v_C, q) {
            const di_L_dt = (V_in * q - v_C) / L;
            const dv_C_dt = (i_L - v_C / R_load) / C;
            return [di_L_dt, dv_C_dt];
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const margin = 50;
            const graphWidth = canvas.width - 2 * margin;
            const graphHeight = (canvas.height - 4 * margin) / 3;

            // Helper function to plot a graph
            function plotGraph(data, title, yLabel, yMin, yMax, yOffset) {
                ctx.beginPath();
                ctx.moveTo(margin, canvas.height - margin - yOffset);

                data.forEach((point, index) => {
                    const x = margin + (graphWidth * index) / (data.length - 1);
                    const y = canvas.height - margin - yOffset - ((graphHeight * (point - yMin)) / (yMax - yMin));
                    ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Draw labels and title
                ctx.fillText(title, margin, canvas.height - margin - yOffset - graphHeight - 10);
                ctx.fillText(yLabel, 10, canvas.height - margin - yOffset - graphHeight / 2);
            }

            plotGraph(q_data, 'Schaltzustand q(t)', 'Zustand (0 oder 1)', 0, 1, 0);
            plotGraph(iL_data, 'Spulenstrom i_L(t)', 'Strom (A)', Math.min(...iL_data), Math.max(...iL_data), graphHeight + margin);
            plotGraph(vC_data, 'Kondensatorspannung v_C(t)', 'Spannung (V)', Math.min(...vC_data), Math.max(...vC_data), 2 * (graphHeight + margin));
        }

        function simulate() {
            if (stopSimulation) return;

            if (!breakSimulation) {
                if (counter > 20){ //automatisches Schalten
					//q = 1-q; //auskommenrieren für manuellen betrieb
					counter = 0;
				}
				counter = counter+1;
				
				const [di_L_dt, dv_C_dt] = buckConverterDynamics(i_L, v_C, q);

                // Euler-Verfahren zur Lösung der DGLs
                
				i_L += di_L_dt * dt;
                v_C += dv_C_dt * dt;
				if (i_L < 0){ //spulenstrom kann nicht kleiner als 0 werden, wegen Diode
					i_L = 0;
				}
				i_C = 1/C*dv_C_dt/dt
				
                // Gesamtzeit aktualisieren
                t_total += dt;

                // Daten speichern
                t_data.push(t_total);
                iL_data.push(i_L);
                vC_data.push(v_C);
                q_data.push(q);
            }

            draw();
        }
		// Initialize canvas and context
        const canvas2 = document.getElementById('canvas');
        const ctx2 = canvas2.getContext('2d');

        // Current and voltage (default values)
        let spulenStrom = 0; // In Amperes
		let kondensatorStrom = 0; // In Amperes
        let voltage = 1; // In Volts

        // Dot properties
        const dotRadius = 3;
        const dotColor = 'yellow';

        // Distance between dots is inversely proportional to voltage
        function getDotSpacing(voltage) {
            return 50 / voltage;
        }

        // Function to draw a wire
        function drawWire(startX, startY, endX, endY) {
            ctx2.beginPath();
            ctx2.lineWidth = 5;
            ctx2.moveTo(startX, startY);
            ctx2.lineTo(endX, endY);
            ctx2.strokeStyle = 'black';
            ctx2.stroke();
        }

        // Function to draw the moving dots along a wire
        function drawDots(startX, startY, endX, endY, current, voltage) {
            const dotSpacing = getDotSpacing(voltage);
            const dotSpeed = current * 2; // Speed of the dots, proportional to current
            const time = Date.now() / 1000; // Get current time in seconds

            const dx = endX - startX;
            const dy = endY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            for (let d = (time * dotSpeed) % dotSpacing; d < distance; d += dotSpacing) {
                const x = startX + Math.cos(angle) * d;
                const y = startY + Math.sin(angle) * d;
                ctx2.beginPath();
                ctx2.arc(x, y, dotRadius, 0, 2 * Math.PI);
                ctx2.fillStyle = dotColor;
                ctx2.fill();
            }
			//static d = (time * dotSpeed)
        }

        function drawKnot(x, y) {
            const knotRadius = 8;
            ctx2.beginPath();
            ctx2.arc(x, y, knotRadius, 0, 2 * Math.PI);
            ctx2.fillStyle = 'black';
            ctx2.fill();
        }

        // Function to create a wire with moving dots
        function createWire(startX, startY, endX, endY, current, voltage) {
            drawWire(startX, startY, endX, endY);
            drawDots(startX, startY, endX, endY, current, voltage);
            drawKnot(startX, startY);
            drawKnot(endX, endY);
        }
	

        // Update function to redraw all wires and dots
        function update() {
            ctx2.clearRect(0, 0, canvas2.width, canvas2.height); // Clear canvas
			
			const conversionFactor = 1/1000000000;
			
			
            // Example wires (you can add more wires here)
			
			spulenStrom += i_L*conversionFactor;
			kondensatorStrom += i_C*conversionFactor/10000000000;
			lastStrom = spulenStrom - kondensatorStrom;
			let kondensatorSpanung = 1 + v_C/10;
            createWire(50, 50, 250, 50, spulenStrom*q, voltage); // oben links
            createWire(250, 50, 250, 350, -spulenStrom*(1-q), voltage); // mitte links
            createWire(50, 350, 50, 50, spulenStrom*q, voltage); // links links
            createWire(250, 350, 50, 350, spulenStrom*q, voltage); // unten links
			createWire(450, 350, 250, 350, spulenStrom, voltage); // unten mitte
			createWire(450, 50, 450, 350, kondensatorStrom, kondensatorSpanung); // mitte rechts
			createWire(250, 50, 450, 50, spulenStrom, voltage); // oben mitte
			createWire(450, 50, 550, 50, lastStrom, voltage); // Last oben
			createWire(550, 50, 550, 350, lastStrom, voltage); // Last oben
			createWire(550, 350, 450, 350, lastStrom, voltage); // Last oben
			
			simulate();
            requestAnimationFrame(update);
        }

        // Display cursor coordinates
        canvas2.addEventListener('mousemove', function(e) {
            const rect = canvas2.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            document.getElementById('coordinates').textContent = `Coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})`;
        });

        // Set up event listeners for input changes
        document.getElementById('currentInput').addEventListener('input', function(e) {
            current = parseFloat(e.target.value);
        });

        document.getElementById('voltageInput').addEventListener('input', function(e) {
            voltage = parseFloat(e.target.value);
        });

        update(); // Start the animation loop
    </script>
</body>
</html>