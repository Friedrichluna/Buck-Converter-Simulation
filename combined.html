<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buck Converter Simulation</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
	<div>
        <label for="automatic_mode">Automatic-Mode: </label>
        <input type="checkbox" id="automatic_mode" checked>
    </div>
    <canvas id="cirquit_canvas" width="800" height="400"></canvas>
    <div>
        <label for="currentInput">Current (A): </label>
        <input type="number" id="currentInput" value="1" step="0.1">
        <label for="voltageInput">Voltage (V): </label>
        <input type="number" id="voltageInput" value="5" step="0.1">
    </div>
    <div id="coordinates">Coordinates: (0, 0)</div>
    <canvas id="plot" width="800" height="600"></canvas>
    <script>
        //----------------------------Differenzialgleichung---------------------------------
        // Parameter
        const V_in = 20; // Eingangsspannung in Volt
        const L = 99e-3; // Induktivität in Henry
        const C = 1e-3; // Kapazität in Farad
        const R_load = 10; // Lastwiderstand in Ohm
        const f = 100e3; // Schaltfrequenz in Hz
        const T = 1 / f; // Schaltperiode in Sekunden
        const dt = 1e-4; // Zeitschritt
		
        // Initialbedingungen
        let i_L = 0; // Anfangsstrom durch die Induktivität
		let i_C = 0; //Kondensatorstrom
        let v_C = 0; // Anfangsspannung über den Kondensator
        let q = 1; // Initialer Schaltzustand (geschlossen)
        let stopSimulation = false; // Flag to stop the simulation
        let breakSimulation = false; // Flag to break the simulation
		let counter = 0;
        let automatic_mode = true; // Automatic mode flag

        // Canvas setup
        const plot_canvas = document.getElementById('plot');
        const ctx = plot_canvas.getContext('2d');

        let t_total = 0; // Gesamtzeit
        const t_data = [];
        const iL_data = [];
        const vC_data = [];
        const q_data = [];

        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') {
                q = 1 - q; // Schaltzustand wechseln
            } else if (event.key === 's') {
                stopSimulation = true; // Stoppen der Simulation
            } else if (event.key === 'b') {
                breakSimulation = !breakSimulation; // Pausieren und Fortsetzen der Simulation
            }
        });

        function buckConverterDynamics(i_L, v_C, q) {
            const di_L_dt = (V_in * q - v_C) / L;
            const dv_C_dt = (i_L - v_C / R_load) / C;
            return [di_L_dt, dv_C_dt];
        }

        function draw_plot() {
            ctx.clearRect(0, 0, plot_canvas.width, plot_canvas.height);

            const margin = 50;
            const graphWidth = plot_canvas.width - 2 * margin;
            const graphHeight = (plot_canvas.height - 4 * margin) / 3;

            // Helper function to plot a graph
            function plotGraph(data, title, yLabel, yMin, yMax, yOffset) {
                ctx.beginPath();
                ctx.moveTo(margin, plot_canvas.height - margin - yOffset);

                data.forEach((point, index) => {
                    const x = margin + (graphWidth * index) / (data.length - 1);
                    const y = plot_canvas.height - margin - yOffset - ((graphHeight * (point - yMin)) / (yMax - yMin));
                    ctx.lineTo(x, y);
                });

                ctx.stroke();

                // Draw labels and title
                ctx.fillText(title, margin, plot_canvas.height - margin - yOffset - graphHeight - 10);
                ctx.fillText(yLabel, 10, plot_canvas.height - margin - yOffset - graphHeight / 2);
            }

            plotGraph(q_data, 'Schaltzustand q(t)', 'Zustand (0 oder 1)', 0, 1, 0);
            plotGraph(iL_data, 'Spulenstrom i_L(t)', 'Strom (A)', Math.min(...iL_data), Math.max(...iL_data), graphHeight + margin);
            plotGraph(vC_data, 'Kondensatorspannung v_C(t)', 'Spannung (V)', Math.min(...vC_data), Math.max(...vC_data), 2 * (graphHeight + margin));
        }

        function simulate() {
            if (stopSimulation) return;

            if (!breakSimulation) {
                if (automatic_mode) { //swithces q automaticcally
                    if (counter > 20){ 
                        q = 1-q; 
                        counter = 0;
                    }
                    counter = counter+1;
                }
				
				const [di_L_dt, dv_C_dt] = buckConverterDynamics(i_L, v_C, q);

                // Euler-Verfahren zur Lösung der DGLs
                
				i_L += di_L_dt * dt;
                v_C += dv_C_dt * dt;
				if (i_L < 0){ //spulenstrom kann nicht kleiner als 0 werden, wegen Diode
					i_L = 0;
				}
				i_C = 1/C*dv_C_dt/dt
				
                // Gesamtzeit aktualisieren
                t_total += dt;

                // Daten speichern
                t_data.push(t_total);
                iL_data.push(i_L);
                vC_data.push(v_C);
                q_data.push(q);
            }
            draw_plot();
        }
        //-----------------------------------Schaltungssimulation--------------------------------------------------------
		// Initialize canvas and context
        const cirquit_canvas = document.getElementById('cirquit_canvas');
        const ctx2 = cirquit_canvas.getContext('2d');

        // Current and voltage (default values)
        let spulenStrom = 0; // In Amperes
		let kondensatorStrom = 0; // In Amperes
        let voltage = 1; // In Volts

        // Dot properties
        const dotRadius = 3;
        const dotColor = 'yellow';

        // Distance between dots is inversely proportional to voltage
        function getDotSpacing(voltage) {
            return 50 / voltage;
        }

        // Function to draw a wire
        function drawWire(startX, startY, endX, endY) {
            ctx2.beginPath();
            ctx2.lineWidth = 5;
            ctx2.moveTo(startX, startY);
            ctx2.lineTo(endX, endY);
            ctx2.strokeStyle = 'black';
            ctx2.stroke();
        }

        // Function to draw the moving dots along a wire
        function drawDots(startX, startY, endX, endY, current, voltage) {
            const dotSpacing = getDotSpacing(voltage);
            const dotSpeed = current * 2; // Speed of the dots, proportional to current
            const time = Date.now() / 1000; // Get current time in seconds

            const dx = endX - startX;
            const dy = endY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);

            for (let d = (time * dotSpeed) % dotSpacing; d < distance; d += dotSpacing) {
                const x = startX + Math.cos(angle) * d;
                const y = startY + Math.sin(angle) * d;
                ctx2.beginPath();
                ctx2.arc(x, y, dotRadius, 0, 2 * Math.PI);
                ctx2.fillStyle = dotColor;
                ctx2.fill();
            }
        }

        function drawKnot(x, y) {
            const knotRadius = 5;
            ctx2.beginPath();
            ctx2.arc(x, y, knotRadius, 0, 2 * Math.PI);
            ctx2.fillStyle = 'black';
            ctx2.fill();
        }
        // Function to create a wire with moving dots
        function createWire(startX, startY, endX, endY, current, voltage,knots) {
            drawWire(startX, startY, endX, endY);
            drawDots(startX, startY, endX, endY, current, voltage);
            if (knots){
                drawKnot(startX, startY);
                drawKnot(endX, endY);
            }
        }

        function createDiode(startX, startY) {
            drawWire(startX-25, startY, startX+25, startY); //horizontal
            drawWire(startX-25, startY+50, startX, startY);
            drawWire(startX+25, startY+50, startX, startY);
            drawWire(startX-25, startY+50, startX+25, startY+50);
        }

        function drawMagneticField(startX, startY, endX, endY, scalingFactor) {
            ctx2.beginPath();
            ctx2.lineWidth = 1;
            ctx2.strokeStyle = 'blue';

            const loops = 5; // Number of loops in the inductor
            const totalLength = endX - startX;
            const loopSpacing = totalLength / (loops * 2); // Space for each half loop

            let currentX = startX;
            console.log(scalingFactor);

            for (let i = 0; i < loops; i++) {
                // Draw magnetic field lines around each loop
                for (let j = 1; j <= scalingFactor; j++) {
                    const offset = j * loopSpacing / (scalingFactor + 1);
                    // Top part of the loop
                    ctx2.moveTo(currentX + offset, startY - loopSpacing);
                    ctx2.bezierCurveTo(
                        currentX + offset - loopSpacing, startY - loopSpacing * 2, 
                        currentX + offset + loopSpacing, startY - loopSpacing * 2, 
                        currentX + offset + loopSpacing, startY - loopSpacing
                    );
                    // Bottom part of the loop
                    ctx2.moveTo(currentX + offset, startY + loopSpacing);
                    ctx2.bezierCurveTo(
                        currentX + offset - loopSpacing, startY + loopSpacing * 2, 
                        currentX + offset + loopSpacing, startY + loopSpacing * 2, 
                        currentX + offset + loopSpacing, startY + loopSpacing
                    );
                }
                currentX += loopSpacing * 2;
            }

            ctx2.stroke();
        }

        function drawInductor(startX, startY, endX, endY,current) {
            ctx2.beginPath();
            ctx2.lineWidth = 5;
            ctx2.strokeStyle = 'black';

            const loops = 5; // Number of loops in the inductor
            const totalLength = endX - startX;
            const loopSpacing = totalLength / (loops * 2); // Space for each half loop

            let currentX = startX;
            for (let i = 0; i < loops; i++) {
                // Draw the uper half of the loop
                ctx2.arc(currentX + loopSpacing, startY, loopSpacing, Math.PI, 0, false);
                currentX += loopSpacing * 2;
                
            }

            ctx2.stroke();
            drawMagneticField(startX, startY, endX, endY, current);
        }
        function createSwitch(startX,startY,state, current, voltage){
            if(state){
                
                shiftY = 0;
                shiftX = 0;
                knots = true;
            }
            else{
                shiftY = 30;
                shiftX = 5;
                knots = false;
            }
            createWire(startX, startY, startX+50-shiftX, startY-shiftY, current, voltage, knots)

        }
	

        // Update function to redraw all wires and dots
        function update() {
            ctx2.clearRect(0, 0, cirquit_canvas.width, cirquit_canvas.height); // Clear canvas
			
			
			spulenStrom += i_L/1000000000;
			kondensatorStrom += i_C/10000000000000000000;
			lastStrom = spulenStrom - kondensatorStrom;
			let kondensatorSpanung = 1 + v_C/10;
            console.log(spulenStrom);
            //Schalterstrang
            createSwitch(100,50,q, spulenStrom*q, voltage);
            createWire(50, 50, 100, 50, spulenStrom*q, voltage,true); // oben links
            createWire(150, 50, 250, 50, spulenStrom*q, voltage,true); // oben links
            createWire(50, 350, 50, 50, spulenStrom*q, voltage,true); // links links
            createWire(250, 350, 50, 350, spulenStrom*q, voltage,true); // unten links
            //Diosenstrang
            createWire(250, 150, 250, 50, spulenStrom*(1-q), voltage,true); // oben
            createWire(250, 350, 250, 150, spulenStrom*(1-q), voltage,true); // unten
            createDiode(250, 150);
            //
			createWire(450, 350, 250, 350, spulenStrom, voltage,true); // unten mitte
            //Kondensatorstrang
			createWire(450, 50, 450, 350, kondensatorStrom, kondensatorSpanung,true); // mitte rechts
            //Spulenstrang
			createWire(250, 50, 320, 50, spulenStrom, voltage,true); // oben mitte
            createWire(400, 50, 450, 50, spulenStrom, voltage,true); // oben mitte
            drawInductor(320, 50, 400, 50, spulenStrom);
			createWire(450, 50, 550, 50, lastStrom, voltage,true); // Last oben
			createWire(550, 50, 550, 350, lastStrom, voltage,true); // Last oben
			createWire(550, 350, 450, 350, lastStrom, voltage,true); // Last oben

            
			
			simulate();
            requestAnimationFrame(update);
        }

        // Display cursor coordinates
        cirquit_canvas.addEventListener('mousemove', function(e) {
            const rect = cirquit_canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            document.getElementById('coordinates').textContent = `Coordinates: (${x.toFixed(2)}, ${y.toFixed(2)})`;
        });
       
        // Set up event listeners for input changes
        document.getElementById('automatic_mode').addEventListener('input', function(e) {
            automatic_mode = e.target.checked;
        });

        document.getElementById('currentInput').addEventListener('input', function(e) {
            current = parseFloat(e.target.value);
        });

        document.getElementById('voltageInput').addEventListener('input', function(e) {
            voltage = parseFloat(e.target.value);
        });


        update(); // Start the animation loop
    </script>
</body>
</html>
